<% include ../partials/header.ejs %>

<!--internal-->
<link href="https://fonts.googleapis.com/css?family=Allan|Averia+Serif+Libre:400,700|Baloo+Paaji|Bowlby+One|Karla|Lobster|Oswald:200|Poppins:200i|Roboto+Mono:300|Satisfy" rel="stylesheet">

<!-- index -->
<div class="index">
  <div class="row">
    <div class="col-12">
      <div class="list-group" id="list-tab" role="tablist">

        <a
        title="This is the introductory chapter!"
        href="#introduction_content"
        id="introduction_a"
        aria-controls="introduction"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action active">
          Introduction
        </a>

        <a
        title="Please buy this content to use it!"
        href="#criticalthinkingwithmultithreadinginc_content"
        id="criticalthinkingwithmultithreadinginc_a"
        aria-controls="critical thinking with multhreading in c"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action">
          Critical Thinking with Multithreading in C
        </a>

        <a
        title="Please buy this content to use it!"
        href="#criticalthinkingwithcwhileloops_content"
        id="criticalthinkingwithcwhileloops_a"
        aria-controls="critical thinking with c while loops"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action">
          Critical Thinking with C while loops
        </a>

        <a
        title="Please buy this content to use it!"
        href="#reverseengineeringjavascriptclickevents_content"
        id="reverseengineeringjavascriptclickevents_a"
        aria-controls="Reverse Engineering JavaScript Click Events"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action">
          Reverse Engineering JavaScript Click Events
        </a>

        <a
        title="Please buy this content to use it!"
        href="#reverseengineeringpythonlists_content"
        id="reverseengineeringpythonlists_a"
        aria-controls="Reverse Engineering Python Lists"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action">
          Reverse Engineering Python Lists
        </a>

        <a
        title="Please buy this content to use it!"
        href="#storingnumbersoutsidethebox_content"
        id="storingnumbersoutsidethebox_a"
        aria-controls="Storing Number Outside the Box"
        data-toggle="list"
        role="tab"
        class="list-group-item list-group-item-action">
          Storing Numbers Outside the Box
        </a>

      </div>
    </div>
  </div>
</div>



<!-- content -->
<div class="content">
    <div class="tab-content" id="nav-tabContent">




      <!-- Introduction -->
      <div id="introduction_content"
      aria-labelledby="introduction_a"
      class="tab-pane fade show active"
      role="tabpanel">
        
        <p class="title1">
          Critical Thinking with Computer Science
        </p>
        
        <br>
        
        <p class="pnormal">
          Critically think to come up with multithreading, reverse engineer
          programming languages, and engineer fantastic algorithms. From
          storing huge numbers to figuring out your favorite programs,
          critically think, with the mindset, and rise to the next level.
        </p>

        <p class="title2">
          Further Thinking
        </p>
        <br>
        <ul class="further-thinking">
          <li>
            What about adding sections to Reverse engineer C while loops in compiling, Reverse engineer python lists in C, Reverse engineer javascript events in C, have a section on creating a program that stores any size numbers
          </li>
          <li>
            Make this ebook a website that someone has to have a premium or book-purchased account in order to access.
          </li>
          <li>
            Have a catchline like, "This book will introduce you to or reinforce you in critical thinking with computer science. I've used the skills in this book to reverse engineer my favorite programs and programming languages, hack through complex bugs, create top-notch custom algorithms, and solve problems".
          </li>
          <li>
            this book may be too specialized.
          </li>
          <li>
            Make sure to get that "social proof" to better sell this ebook.
          </li>
        </ul>

      </div>





      <!-- Critical thinking with multithreading in C -->
      <div id="criticalthinkingwithmultithreadinginc_content"
      arialabelledby="criticalthinkingwithmultithreadinginc_a"
      class="tab-pane fade show"
      role="tabpanel">

        <p class="title1">
          Critical Thinking with Multithreading in C
        </p>
        <p class="info">
          Dustin West <br>
          Started 5/9/18
        </p>
        <br>
        <p class="pnormal">
          I don't know how much you know about C, but it's a way to make
          programs that perform one instruction at a time. <b>Let's think
          critically about performance optimizations in a C program!</b>
        </p>
        <br>
        <p class="code1">
          Example A: <br>
          1. int x = 5; <br>
          2. int y = get_user_int_input(); <br>
          3. int z = 10; <br>
          4. int alpha = x + y + z;
        </p>
        <br>
        <p class="pnormal">
          Usually this C program would happen <b>one line at a time</b>
          like this:
        </p>
        <br>
        <p class="code1">
          Possibility A-1: <br>
          1. Store a number called x with the value 5 in memory wherever the
          program wants to put it <br>
          2. Wait for a user to enter a number, then store that number under
          the name y in memory wherever the program wants to put it <br>
          3. Store a number called z with the value 10 in memory wherever the
          program wants to put it <br>
          4. Store a number called alpha with the value of x + y + z or 5 +
          the user's number + 10 in memory wherever the program wants to put
          it
        </p>
        <br>
        <p class="pnormal">
          But what if we wanted to improve the performance of our C programs
          by adding in this rule, maybe carried out by the <b>operating
          system</b>:
        </p>
        <br>
        <p class="italic1">
          <i>
            Whenever a function is called, assign the work to a new
            program/process/thread/fiber and go to the next line.
          </i>
        </p>
        <br>
        <p class="pnormal">
          So, <b>if</b> our Operating System somehow knew when a function was
          called, we could write it to create (called "fork") a
          new program/process/thread/fiber made specifically for running the
          function and then when the function is done running that new
          program/process/thread/fiber hands the results back to the
          parent/calling/original program!
        </p>
        <br>
        <p class="pnormal">
          Then the C program would run one line at a time, but skip over
          every line that has a function! It would run something like this:
        </p>
        <br>
        <p class="code1">
          Possibility A-2: <br>
          1. Store a number called x with the value 5 in memory wherever the
          program wants to put it <br>
          2. Start up a new program/process/thread/fiber that will wait for a
          user to enter a number, then hand the number back to the original
          program/process/thread/fiber to be stored with the name y in memory
          wherever the program wants to put it when the user inputs a number,
          move on to the next line... <br>
          3. Store a number called z with the value 10 in memory wherever the
          program wants to put it <br>
          4. Store a number called alpha with the value of x + y… <b>wait a
          moment</b> there's a good chance we haven't received that number
          from the user yet so we still haven't gotten back a response from
          the program/process/thread/fiber that's running the
          <i>get_user_int_input function.</i> So it's just a bunch of garbage
          right now because it's value hasn't been set. So we <b>can't</b>
          calculate alpha yet! <b>Oh no!</b>
        </p>
        <br>
        <p class="pnormal">
          Since we modified our C runtime by adding in that new rule, we ran
          into a problem. What if the parent program/process/thread/fiber is
          waiting on functions on other program/process/thread/fibers to
          return back something before it can continue to execute?! This is
          something I thought about and thought I solved it until <b>I
          realized there was more work to do.</b> See, I thought I found the
          answer by just adding in this new rule:
        </p>
        <br>
        <p class="italic1">
          <i>
            Whenever a variable or an expression is waiting to be assigned to
            the value of a not completed function, either create (fork)
            another program/process/thread/fiber to run that line of code and
            skip over it, or halt the program/process/thread/fiber to wait
            until the variable or expression can be evaluated (it's function
            is done).
          </i>
        </p>
        <br>
        <p class="pnormal">
          And this seems like a pretty good idea at first, but as you may
          already tell, it's got a huge flaw involving that you must tell
          computers <b>everything</b> they need to do in order to accomplish
          a task. So the program might run something like this:
        </p>
        <br>
        <p class="code1">
          Possibility A-3: <br>
          1. Store a number called x with the value 5 in memory wherever the
          program wants to put it <br>
          2. Start up a new program/process/thread/fiber that will wait for a
          user to enter a number, then hand the number back to the original
          program/process/thread/fiber to be stored with the name y in memory
          wherever the program wants to put it when the user inputs a
          number <br>
          3. Store a number called z with the value 10 in memory wherever the
          program wants to put it <br>
          4. Store a number called alpha with the value of x + … oh yeah y
          isn't done being evaluated, it's
          created/forked program/process/thread/fiber hasn't returned
          anything so let's either assign this line of code to another
          program/process/thread/fiber and skip over it or wait until y can
          be evaulated! O ya! <b>Wait a moment...</b> How do I know y hasn't
          been evaluated yet? I'm a computer, I can lookup y in my list of
          variables, it's got some value, and I can also see that another
          program/process/thread/fiber is being evaluated... but... how do I
          know y isn't done being evaluated? If the programmer who wrote me
          didn't tell me specifically that y isn't done being evaluated, I
          <b>can't</b> know that I have to wait on y... so... <b>I'm just
          gonna do a bunch of random stuff that's hard to debug</b>, k? 👍
        </p>
        <br>
        <p class="pnormal">
          The problem we have with these two rules is we need another
          rule/setup, but setup is more accurate because we need to have the
          information available to enforce the second rule. We didn't have
          the information beforehand because all we had were a list of
          variables and a list of executing functions (running on other
          programs/process/threads/fibers). Not only for solving this
          multiprogramming problem but maybe just to be useful in the future,
          let's try applying a <b>table setup!</b> What about if every time a
          variable was declared, we set up a <b>table</b> in memory wherever
          the program wants to put it that has information about the
          variable. Let's try making our standard table look like this:
        </p>
        <br>
        <p class="code2">
          Example B:
        </p>
        <table class="code1 table table bordered table-hover">
          <tr>
            <th>name</td><td>(variable name)</td>
          </tr>
          <tr>
            <th>value</td><td>(variable value)</td>
            </tr>
          <tr>
            <th>type</td><td>(int, double, struct, enum, char, char *, just
                              the type of the variable)</td>
          </tr>
          <tr>
            <th>evaluated</td><td>(whether the variable is evaluated, if all
                                  functions and lines of code it depends on
                                  are done running, true or false, 1 or
                                  0)</td>
          </tr>
        </table>
        <br>
        <p class="pnormal">
          Notice this table has the regular stuff like a name, value, and
          type, but also a unique field called <i>evaluated</i> which, as
          it's description displays, should be able to be used in conjunction
          with the two other rules in order to make multiprogrammed C
          programs!
        </p>
        <br>
        <p class="pnormal">
          With these three rules and table setup, we can come across lines
          with functions directly or indirectly involved, assigning them to
          some other part of the or other CPU, and skipping them or halting
          at them, in order to run multiple parts of the program at once
          while also being able to <b>evaluate and execute code involving
          functions, in turn, seamlessly</b>!
        </p>
        <br>
        <p class="pnormal">
          Now that we have a table setup, let's add two more rules to
          accommodate it:
        </p>
        <br>
        <p class="italic1">
          <i>
            Whenever a variable assignment is depending on a function or
            lines of code involving a function, either create (fork) a new
            program/process/thread/fiber to run that variable assignment and
            skip to the next line or halt the program/process/thread/fiber to
            wait until the variable can be assigned
          </i>
        </p>
        <p class="pnormal">
          And
        </p>
        <p class="italic1">
          <i>
            Whenever a line of code is dependent on an expression where not
            all of the variables involved have their evaluated attribute set
            to true, either create (fork) a new program/process/thread/fiber
            to run that line of code and skip to the next line or halt the
            program/process/thread/fiber to wait until the variable can be
            assigned.
          </i>
        </p>
        <br>
        <p class="pnormal">
          Let's see how our C program would now work, line by line:
        </p>
        <br>
        <p class="code1">
          Possibility A-4: <br>
          1. Create a variable table somewhere in memory wherever the program
          wants to put it. Assign the <i>name</i> attribute to "x". Since we
          <b>don't</b> have to wait on a function or other line of code to
          finish before assigning the value, we can set the value now; assign
          the <i>value</i> attribute to "5". Assign the <i>type</i> attribute
          to "int". Since we <b>don't</b> have to wait on a function or other
          line of code to finish, the value can be or is already assigned at
          the time of this variable assignment execution code, so set the
          <i>evaluated</i> attribute to "1" (true). <br>
          2. Create a variable table somewhere in memory wherever the program
          wants to put it. Assign the <i>name</i> attribute to "y". Since we
          <b>do</b> have to wait on a function to finish before assigning,
          then create a new (fork) program/process/thread/fiber, run the
          <i>get_user_int_input</i> function in it, and assign the returned
          value of the function to the <i>value</i> attribute of the table
          and the <i>evaluated</i> attribute of the table to "1" (true) when
          the function is done running. Assign the <i>type</i> attribute to
          "int". Since we <b>do</b> have to wait on a function to finish
          before assigning the <i>value</i> attribute we can say that the
          variable will not be evaluated yet and so assign the
          <i>evaluated</i> attribute to 0 (false). <br>
          3. Create a variable table somewhere in memory wherever the program
          wants to put it. Assign the <i>name</i> attribute to "z". Since we
          <b>don't</b> have to wait on a function or other line of code to
          finish before assigning the value, we can set the value now; assign
          the <i>value</i> attribute to "10". Assign the <i>type</i>
          attribute to "int". Since we <b>don't</b> have to wait on a
          function or other line of code to finish, the value can be or is
          already assigned at the time of this variable assignment execution
          code, so set the <i>evaluated</i> attribute to "1" (true). <br>
          4. Create a variable table somewhere in memory wherever the program
          wants to put it. Assign the <i>name</i> attribute to "alpha". Since
          the assignment value is an expression instead of a number we need
          to check to make sure every variable is evaluated and there are no
          functions in order to execute this line of code as-is: iterating
          over each operand in the expression, we check to see if each one is
          evaluated and if it is a function:
          <br>
          &nbsp&nbsp&nbsp&nbsp4a. Going to the table of "x", the <i>evaluated</i> attribute
          <br>
          &nbsp&nbsp&nbsp&nbspis "true" and it is also not a function, moving on...
          <br>
          &nbsp&nbsp&nbsp&nbsp4b. Going to the table of "y", the <i>evaluated</i> attribute
          <br>
          &nbsp&nbsp&nbsp&nbspis "false", so now we will do whatever the operating system
          <br>
          &nbsp&nbsp&nbsp&nbspdoes when encountering a function or line of code waiting on a
          <br>
          &nbsp&nbsp&nbsp&nbspfunction: either create (fork) a new
          <br>
          &nbsp&nbsp&nbsp&nbspprogram/process/thread/fiber to run the line of code and
          <br>
          &nbsp&nbsp&nbsp&nbspskipping to the next line or wait until this line of code can
          <br>
          &nbsp&nbsp&nbsp&nbspbe evaluated (talking about the main, parent program doing the
          <br>
          &nbsp&nbsp&nbsp&nbspwaiting here).
          <br>
          , set the <i>evaluated</i> attribute to false
        </p>
        <p class="pnormal">
          <b>With these two rules and the variables-are-tables setup, we have
          just critically thought about how we might improve performance on C
          programs by altering the operating system to support
          multiprogramming/multithreading!</b>
        </p>
        <p class="title2">
          Further Thinking:
        </p>
        <ul class="further-thinking">
          <li>
            What about tables for the functions?
          </li>
          <li>
            If we must wait until every variable is evaluated to evaluate an expression, maybe use signals or a while loop to pick back up the execution once every variable is evaluated.
          </li>
          <li>
            If you think about how C was made, should not even a one-value item be an expression: does not the C compiler need to evaluate "15" as an expression just like "2 + 2" or "a – b"? Wouldn't that make sense?
          </li>
          <li>
            What about if the table is a linked list for any size or properties
          </li>
          <li>
            We also might consider the operating system making sure to not start too many threads, maybe changing the approach of skip or wait depending on metadata like:
          </li>
          <ul>
            <li>
              record whether each function is a user input or long running or short running function so the operating system can look up the function info and use algorithms to decide what exact decisions to make
            </li>
            <li>
              Have a working counter of the number of child programs/processes/threads/fibers running under the main program/process/thread/fiber
            </li>
          </ul>
          <li>
            What about making sure to have the C runtime support any size table by using a dynamic, variable-based/option-set memory allocation size for when we need to allocate some memory for a new table, in case we want to add more properties to the fixed standard table or go with the linked list attribute approach for the tables
          </li>
          <li>
            Make sure to include videos especially that video on your OS page.
          </li>

        </ul>

      </div>





      <!-- Critical thinking with C while loops -->
      <div id="criticalthinkingwithcwhileloops_content"
      aria-labelledby="criticalthinkingwithcwhileloops_a"
      class="tab-pane fade show"
      role="tabpanel">

        <p class="title1">
          Critical thinking with C while loops
        </p>
        <br>
        <p class="info">
          Dustin West <br>
          Started 5/9/18
        </p>
        <br>
        <p class="pnormal">
          I don't know how much you know about C, but in this programming
          language is a way to make infinite loops that loop over code
          forever until told to stop. <b>Let's think critically about while
          loops in C!</b>
        </p>
        <br>
        <p class="pnormal">
          Here is a piece of C code that we will pick apart:
        </p>
        <br>
        <p class="code1">
          Example A: <br>
          1. int counter = 0; <br>
          2. while (counter < 3) { <br>
          3.&nbsp&nbsp&nbsp&nbsp&nbspcounter = counter + 1; <br>
          4. }
        </p>
        <br>
        <p class="pnormal">
          When compiled, the program might run something like this:
        </p>
        <br>
        <p class="code1">
          Possibility A-1: <br>
          1. Make room in memory for variable "counter", set it to 0. <br>
          2. forever: run 2a and 2b <br>
          &nbsp&nbsp&nbsp&nbsp&nbsp2a. if counter is not less than 3, break
          out of the loop <br>
          &nbsp&nbsp&nbsp&nbsp&nbsp2b. increment counter <br>
        </p>
        <br>
        <p class="pnormal">
          But how does this program actually compile into executable
          instructions? Perhaps one way is that instead of compiling while
          loops to execute some extra instruction that checks their statement
          every time the loop runs, the compiler might actually write extra C
          code directly into the file and alter the while loop condition like
          this (compile process):
        </p>
        <br>
        <p class="code1">
          Possibility A-2: <br>
          1. write if statement directly inside opening curly brace <br>
          2. set condition of said if statement to inverted/notted/not
          condition of while loop <br>
          3. set code block inside said if statement so it breaks out of loop
          if the said if statement triggers <br>
          4. set condition inside of while loop to "true" so it runs forever
          <br>
        </p>
        <p class="pnormal">
          So the code, right before actual compiling, could look like this:
        </p>
        <br>
        <p class="code1">
          Posibiity A-3: <br>
          1. int counter = 0; <br>
          2. while (true) { <br>
          3.&nbsp&nbsp&nbsp&nbspif (!(counter < 3)) { <br>
          4.&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break; <br>
          5.&nbsp&nbsp&nbsp&nbsp} <br>
          6.&nbsp&nbsp&nbsp&nbspcounter = counter + 1; <br>
          7. }
        </p>
        <p class="pnormal">
          Now, what about how a machine might actually compile an infinite
          loop? <br>
          Let's use this code as an example:
        </p>
        <br>
        <p class="code1">
          Example B: <br>
          1. while (true) { <br>
          2. <br>
          3. }
        </p>
        <br>
        <p class="pnormal">
          Well, how do machines actually execute C code? Don't they do it one
          line at a time, as taught that C does? Would not when a C program
          gets compiled it gets converted into a bunch of instructions that
          a machine can read? Thinking further, if a machine reads a C
          program from left to right, top to bottom, would not that mean the
          machine is able to start a program by <b>JUMPING</b> to the first
          instruction and start executing it from there? How else would a
          machine know where to start executing a C program? Therefore, a
          machine must have the ability to <b>jump</b> instructions, so what
          if one of those instructions it can perform is to jump other
          instructions? Like this (compiled instructions):
        </p>
        <br>
        <p class="code1">
          Possibility B-1: <br>
          1. next instruction <br>
          2. if "true" is false <br>
          3.&nbsp&nbsp&nbsp&nbsp&nbspbreak <br>
          4. else <br>
          5.&nbsp&nbsp&nbsp&nbsp&nbspnext instruction <br>
          6. next instruction <br>
          7. jump to instruction one
        </p>
        <br>
        <p class="pnormal">
          That list of instructions is assuming pre-compile, temporary
          code changing by the compiler as described as a possibility above
          is actually carried out so the pre-compile time code looks like
          this:
        </p>
        <br>
        <p class="code1">
          Example B-2: <br>
          1. while (true) { <br>
          2.&nbsp&nbsp&nbsp&nbsp&nbspif (!(true)) { <br>
          3.&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break; <br>
          5.&nbsp&nbsp&nbsp&nbsp&nbsp} <br>
          6. <br>
          7. } <br>
        </p>
        <br>
        <p class="pnormal">
          <b>We have just thought Critically about C While Loops!</b>
        </p>
        <br>
        <p class="title2">
          Further Thinking
        </p>
        <ul class="further-thinking">
          <li>
            this doesnt actually reflect how compiling happens, but rather is
            critical thinking about how it might happen, using the smallest
            information to come to the largest conclusions
          </li>
        </ul>


      </div>




      <!-- Reverse Engineering Javascript Click Events -->
      <div id="reverseengineeringjavascriptclickevents_content"
      aria-labelledby="reverseengineeringjavascriptclickevets_a"
      class="tab-pane fade show"
      role="tabpanel">
        Reverse Engineering JavsaScript Click Events YO
      </div>




      <!-- Reverse Engineering Python Lists -->
      <div id="reverseengineeringpythonlists_content"
      aria-labelledby="reverseengineeringpythonlists_a"
      class="tab-pane fade show"
      role="tabpanel">
        Reverse Engineering Python Lists
        They probably use doubly linked lists
        
        Video Script Diggity:
        Intro:
          this video does not use all best practices such as completely correct memory management
          it is designed to be as code-friendly as possible
        Go over python list concepts + append + pop
        go over basic python list
        recreate basic python list in C
        go over python list append and pop again
        recreate python append and pop in C
        closure
        
      </div>




      <!-- Storing Numbers Outside the Box -->
      <div id="storingnumbersoutsidethebox_content"
      aria-labelledby="storingnumbersoutsidethebox_a"
      class="tab-pane fade show"
      role="tabpanel">

        <p class="title1">
          Storing Numbers Outside the Box
        </p>
        <br>
        <p class="info">
          Dustin West <br>
          Started 5/11/18
        </p>
        <br>
        <p class="pnormal">
          By critically thinking to solve your problems, you're going to
          learn how to store thousands of digits large and precise numbers in
          the C programming language which by default only stores up to about
          20 digits large and 15 digits precise!
        </p>
        <br>
        <p class="pnormal">
          One time I wanted to calculate the number PI using an algorithm
          I thought of earlier and the C programming language. I instantly
          realized that C only support numbers up to I think over 15 decimal
          places, so my PI calculations would be terribly imprecise. <b>Not
          what I wanted</b>. <br>
          I thought that of a few ways I might overcome this obstacle. I
          thought at first that I might write my own C "struct" so every time
          I want to store a number, I declare it as my struct's type instead
          of "int" type or "float" type or something like that. I also
          thought of what I might put in my structure to allow it to hold
          numbers. At first (and I did this for two weeks), I thought I would
          put two arrays of 1s and 0s (boolean values) in my struct, one for
          storing digits to the left of the decimal point, in binary, and the
          other for storing digits to the right of the decimal point, also in
          binary. But I soon realized my program had the same flaws as the C
          runtime. The more precision you add to a binary number does not
          directly or even clearly affect the amount of precision you will
          have in converting it back to a base 10 (regular) number. <br>
          So instead, I actually thought some more and decided to store every
          number in base 10, with my structs. I did this by putting two
          arrays in my struct, one was an array of signed bytes for the
          digits left of the decimal point and the other was also an array of
          signed bytes for the digits right of the decimal point.
        </p>
        <br>
        <p class="pnormal">
          From there everything is intuitive. Adding, subtracting,
          multiplying, and dividing these numbers? Just carry over pencil and
          paper algorithms to C algorithms, because you're still operating in
          base 10! And if you can add, subtract, multiply, and divide, you
          can go forward to exponents, square roots, and trig functions in
          order to calulate PI!
        </p>
        <p class="pnormal">
          All the code I am about to show you will be in one file, with the
          functions being defined above the "main" function and the defines,
          the includes, <b>everything</b> being on page, in one file, that
          will compile and run!
          Now let's look at some code to make these structs:
        </p>
        <br>
        <ol class="code1">
          Example A:
          <li>#include &ltstring.h&gt</li>
          <li>#include &ltstdio.h&gt</li>
          <li>#include &ltstdint.h&gt</li>
          <li>#include &ltstdbool.h&gt</li>
          <li></li>
          <li>#define DIGITS 3</li>
          <li>#define PRECISION 3</li>
          <li></li>
          <li>typedef struct {</li>
          <li>&nbsp int8_t values[DIGITS];</li>
          <li>&nbsp int8_t precision[DIGITS];</li>
          <li>} decimal;</li>
          <li></li>
          <li>int main(void) {</li>
          <li>&nbsp return 0;</li>
          <li>}</li>
        </ol>

        <br>
        <p class="pnormal">
          Here I will walk you through, line by line, what's happening in
          this program:
        </p>
        <br>
        <ol class="code1">
          Explanation A-1:
          <li>include this library called "string.h" that will allow us to
          use the "strlen" function to determine the length of a string and
          the "atoi" function that will allow us to convert a string
          character to an integer (so "1" gets converted to 1).</li>
          <li>include this library called "stdio.h" that will allow us to
          print things out using the "printf" function</li>
          <li>include this library called "stdint.h" that will allow us to
          use signed bytes (that range from -127 to 127) in our program by
          declaring variables as type "int8_t"</li>
          <li>include this library called "stdbool.h" that will allow us to
          use boolean values (true/false, 1/0)</li>
          <li></li>
          <li>define a constant variable, "DIGITS", to be 3, we will use
          this variable often to keep track of how big our numbers max out at
          and abstract our algorithms accordingly</li>
          <li>define a constant, variable "PRECISION", to be 3, that has the
          same purpose and workings as "DIGITS" except we will use it to keep
          track of how precise our numbers can be.</li>
          <li></li>
          <li>declare a new kind of datatype (a struct)...</li>
          <li>make it have an array of signed bytes that is "DIGITS" large
          and will be reffered to by the name "values"</li>
          <li>make it have an array of signed bytes that is "PRECISION"
          large and will be reffered to by the name "places"</li>
          <li>call the data type/struct "decimal", so now we can declare
          variables of that type just like "int i" or "char c"!</li>
          <li></li>
          <li>the function that will automatically run when the program
          starts executing, the "main" function, defined by the C standard.
          It doesn't take any arguments or fancy stuff, just start running.</li>
          <li>return a successful run of the main function</li>
          <li>exit the main function</li>
        </ol>
        <br>
        <p class="pnormal">
          Now, we have a way to STORE numbers of any size, we can go in and
          change the "DIGITS" or "PRECISION" and make our numbers bigger.
          <br>
          However, we are missing a way to convert between numbers and
          our new fangled data type. I actually never thought about why until
          I wrote this book (facepalm) (lol) (:/) (-_-) (still balling) but
          I went along the route where we convert strings to our data type
          and our data type to strings, back and forth, so we can REALLY
          start being able to easily store numbers. <br>
          The function I present you with will take in input in the form of
          one data type and convert it to another data type and hand back the
          the output. There is one function, "StoD" which stands
          for "string to decimal" and the name
          is pretty self explanatory considering this text.
        </p>
        <br>
        <p class="pnormal">
          Lets look at how we will use this function, line by line,
          in the main function, pretending all the other code is there and
          we just can't see it:
        </p>
        <br>
        <ol class="code1">
          Example B:
          <li>int main(void) {</li>
          <li>&nbsp char * user_num = get_string();</li>
          <li>&nbsp decimal * converted_to_decimal = StoD(user_num);</li>
          <li>}</li>
        </ol>
        <br>
        <p class="pnormal">
          Here is what happens, line by line, in the main function:
        </p>
        <br>
        <ol class="code1">
          <li>standard main function declaration stuff</li>
          <li>wait on a user to enter a string and store it in the
          "user_num" string variable</li>
          <li>convert from the string "user_num" to a decimal and hand it
          back to be stored in the decimal "converted_to_decimal"</li>
          <li>exit the main function</li>
        </ol>
        <br>
        <p class="pnormal">
          That program took a string from the user, converted it to a
          decimal, and exited.
        </p>
        <br>
        <p class="pnormal">
          Now let's look at how we will implement our StoD function, all in
          one block of code, and then I will explain, line by line, what
          everything does and why it works :). Here is the function:
        </p>
        <br>
        <ol class="code1">
          Example C:
          <li>decimal * StoD(char * string) {</li>
          <li></li>
          <li>&nbsp decimal * out = malloc(sizeof(decimal));</li>
          <li>&nbsp int string_length = strlen(in);</li>
          <li>&nbsp int decimalPlace = -1;</li>
          <li>&nbsp int leftHandEnd;</li>
          <li></li>
          <li>&nbsp for (int stringIndex = 0; stringIndex < string_length; stringIndex++) {</li>
          <li>&nbsp&nbsp&nbsp if (string[stringIndex] == ".") {</li>
          <li>&nbsp&nbsp&nbsp&nbsp&nbsp decimalPlace = stringIndex;</li>
          <li>&nbsp&nbsp&nbsp }</li>
          <li>&nbsp }</li>
          <li>&nbsp if (decimalPlace == -1) {</li>
          <li>&nbsp&nbsp&nbsp leftHandEnd = string_length - 1;</li>
          <li>&nbsp } else {</li>
          <li>&nbsp&nbsp&nbsp leftHandEnd = decimalPlace - 1;</li>
          <li>&nbsp }</li>
          <li></li>
          <li>&nbsp for (int stringIndex = leftHandEnd, arrayIndex = digits - 1; stringIndex >= 0; stringIndex--, arrayIndex--) {</li>
          <li>&nbsp&nbsp&nbsp out->values[arrayIndex] = atoi(string[stringIndex]);</li>
          <li>&nbsp }</li>
          <li>&nbsp if (decimalPlace != -1) {</li>
          <li>&nbsp&nbsp&nbsp for (int stringIndex = decimalPlace + 1, arrayIndex = 0; stringIndex < string_length; stringIndex ++, arrayIndex++) {</li>
          <li>&nbsp&nbsp&nbsp&nbsp&nbsp out->places[arrayIndex] = atoi(string[stringIndex]);</li>
          <li>&nbsp&nbsp&nbsp }</li>
          <li>&nbsp }</li>
          <li></li>
          <li>&nbsp return out;</li>
          <li>}</li>
        </ol>
        <br>
        <p class="normal">
          Now I will explain, line by line, why this function works:
        </p>
        <ol class="code1">
          Explanation C-1:
          <li>declare a function called "StoD" which will take in a string as a parameter and return a decimal</li>
          <li></li>
          <li>allocate space for and declare the decimal that we will be returning</li>
          <li>determine the length of the input string and store it in a variable called "string_length"</li>
          <li>declare a variable called "decimalPlace" and set it to the default value of -1 which represents there being do decimal</li>
          <li>declare a variable called "leftHandEnd" which will later tell us where the left hand side/side to left of decimal will end (there is an invisible decimal past the last digit on the right if none found)</li>
          <li></li>
          <li>declare a temporary variable "stringIndex" and set it to 0. forever, execute lines 9-11 and after each loop, if "string_index" is less than "string_length", continue, but if it's not, break out of the loop. Also after every loop, increment "string_index".</li>
          <li>&nbsp if the current character in the string is a period, execute line 10</li>
          <li>&nbsp&nbsp&nbsp set the "decimalPlace" variable to be the index of the decimal point in the string</li>
          <li></li>
          <li></li>
          <li>if there <b>IS NOT</b> a decimal point in the string, the left hand side of the string will end at the index of it's length minus one, so execute line 14</li>
          <li>&nbsp set "leftHandEnd" to "string_length" - 1</li>
          <li>else, there <b>MUST BE</b> a decimal point in the string, the left hand side of the string will end at the index of the decimal point minues one, so execute line 16</li>
          <li>&nbsp set "leftHandEnd" to "decimalPlace" - 1</li>
          <li></li>
          <li></li>
          <li>declare a temporary variable called "stringIndex" and set it to "leftHandEnd", declare a temporary variable called "arrayIndex" and set it to (digits - 1) <br>
          &nbsp&nbsp&nbsp&nbsp, loop forever and during each loop, execute line 20, and after each loop, if "stringIndex" is not greater than or equal to 0, then break out of the loop. Also after each loop, decrement "stringIndex" and decrement "arrayIndex"</li>
          <li>&nbsp go inside the decimal called "out", refer to it's array called "values", and set the array item at the index of "arrayIndex" to the value of the character in the string "string" at index "stringIndex" converted to an integer</li>
          <li></li>
          <li>if there is a decimal point in the string, execute lines 23-24</li>
          <li>&nbsp declare a temporary variable "stringIndex" and set it to (decimalPlace + 1), declare a temporary variable "arrayIndex" and set it to 0, during each loop, execute line 24, after each loop, check if "stringIndex" is less than "string_length", if it is, continue, but if it is not, break out of the loop. Also after every loop, increment "stringIndex" and increment "arrayIndex"</li>
          <li>&nbsp&nbsp&nbsp go inside the decimal called "out", refer to it's array called "places", and set the value of the item at the index of "arrayIndex" to the value of the character in the string "string" at index "stringIndex" converted to an integer</li>
          <li></li>
          <li></li>
          <li></li>
          <li>Now everything is converted, return the decimal "out"</li>
          <li></li>
        </ol>
        <br>
        <p class="pnormal">
          This algorithm works, and I encourage you to draw out on paper it
          being used in action with as many positive, decimal or no decimal,
          valid integer/fractional strings as possible.
        </p>
        <br>
        <p class="pnormal">
          Now that we have a way to store numbers in base 10 and a way to
          convert strings to them via automation! <br>
          <b>We have just thought Critically about Storing Numbers Outside
          the Box!</b>
        </p>
        <br>
        <p class="pnormal">
          Here is the full code:
        </p>
        <ol class="code1">
          <li>#include &ltstring.h&gt</li>
          <li>#include &ltstdio.h&gt</li>
          <li>#include &ltstdint.h&gt</li>
          <li>#include &ltstdbool.h&gt</li>
          <li></li>
          <li>#define DIGITS 3</li>
          <li>#define PRECISION 3</li>
          <li></li>
          <li>typedef struct {</li>
          <li>&nbsp int8_t values[DIGITS];</li>
          <li>&nbsp int8_t precision[DIGITS];</li>
          <li>} decimal;</li>
          <li></li>
          <li>decimal * StoD(char * string) {</li>
          <li></li>
          <li>&nbsp decimal * out = malloc(sizeof(decimal));</li>
          <li>&nbsp int string_length = strlen(in);</li>
          <li>&nbsp int decimalPlace = -1;</li>
          <li>&nbsp int leftHandEnd;</li>
          <li></li>
          <li>&nbsp for (int stringIndex = 0; stringIndex < string_length; stringIndex++) {</li>
          <li>&nbsp&nbsp&nbsp if (string[stringIndex] == ".") {</li>
          <li>&nbsp&nbsp&nbsp&nbsp&nbsp decimalPlace = stringIndex;</li>
          <li>&nbsp&nbsp&nbsp }</li>
          <li>&nbsp }</li>
          <li>&nbsp if (decimalPlace == -1) {</li>
          <li>&nbsp&nbsp&nbsp leftHandEnd = string_length - 1;</li>
          <li>&nbsp } else {</li>
          <li>&nbsp&nbsp&nbsp leftHandEnd = decimalPlace - 1;</li>
          <li>&nbsp }</li>
          <li></li>
          <li>&nbsp for (int stringIndex = leftHandEnd, arrayIndex = digits - 1; stringIndex >= 0; stringIndex--, arrayIndex--) {</li>
          <li>&nbsp&nbsp&nbsp out->values[arrayIndex] = atoi(string[stringIndex]);</li>
          <li>&nbsp }</li>
          <li>&nbsp if (decimalPlace != -1) {</li>
          <li>&nbsp&nbsp&nbsp for (int stringIndex = decimalPlace + 1, arrayIndex = 0; stringIndex < string_length; stringIndex ++, arrayIndex++) {</li>
          <li>&nbsp&nbsp&nbsp&nbsp&nbsp out->places[arrayIndex] = atoi(string[stringIndex]);</li>
          <li>&nbsp&nbsp&nbsp }</li>
          <li>&nbsp }</li>
          <li></li>
          <li>&nbsp return out;</li>
          <li>}</li>
          <li></li>
          <li>int main(void) {</li>
          <li>&nbsp char * user_num = get_string();</li>
          <li>&nbsp decimal * converted_to_decimal = StoD(user_num);</li>
          <li>}</li>
        </ol>



        <br>
        <p class="title2">
          Further Thinking:
        </p>
        <ul class="further-thinking">
          <li>
            I know what a * is please don't hmu saying "do you even know
            what a pointer is" because I'm going to drink my water and
            be slightly annoyed and continue coding, lol.
          </li>
          <li>
            I actually used the "get_string" function without defining it,
            because I didn't want to clutter up and make bigger the already
            large text :/ so if you try to compile this and can't, lol just
            tell me @ghostofmmo@gmail.com and I'll send you the get_string()
            function I use! :)
          </li>
          <li>
            what about the values and places being in linked lists instead of
            an array?
          </li>
          <li>
            what about numbers being negative?
          </li>
          <li>
            what about numbers being too big or too small to store?
          </li>
          <li>
            what about functions to automatically initialize decimals?
          </li>
          <li>
            what about using arrays of integers and manipulating them at a
            bit level in order to create a "super int" of sorts and using it on both
            sides but with different algs for converting
          </li>
          <li>
            My real functions account for most of the stuff you might think,
            negatives, oversize, undersize, errenous usage, debugging, and
            adding, subtracting, multiplying, and dividing, automating
            decimal allocation, manual memory management and more. hmu for it
            at ghostofmmo@gmail.com
          </li>
        </ul>
      </div>

    </div>
  </div>


<% include ../partials/footer.ejs %>